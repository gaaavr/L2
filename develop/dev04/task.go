package main

import (
	"fmt"
	"sort"
	"strings"
)

/* Написать функцию поиска всех множеств анаграмм по словарю.


Например:
'пятак', 'пятка' и 'тяпка' - принадлежат одному множеству,
'листок', 'слиток' и 'столик' - другому.

Требования:
Входные данные для функции: ссылка на массив, каждый элемент которого - слово на русском языке в кодировке utf8
Выходные данные: ссылка на мапу множеств анаграмм
Ключ - первое встретившееся в словаре слово из множества. Значение - ссылка на массив, каждый элемент которого,
слово из множества.
Массив должен быть отсортирован по возрастанию.
Множества из одного элемента не должны попасть в результат.
Все слова должны быть приведены к нижнему регистру.
В результате каждое слово должно встречаться только один раз.

*/

func main() {
	// Дан исходный массив слов
	arr := []string{"пЯтка", "лиСток", "лиСТок", "слиток", "ПЯТАК", "лишний", "лишний", "слиток", "пятка", "тяпка", "столик"}
	// Печатаем получившийся результат с анаграммами
	fmt.Println(findAnagrams(arr))
}

// Функция принимает на вход слайс строк
func findAnagrams(arr []string) map[string][]string {
	// Объявляем переменную для подсчёта суммы байтов каждый строки
	var sum int
	// Иницилизируем две мапы: одну для сопоставления слов с одинаковой суммой байт,
	// вторую для проверки повторения слов
	sumByte := make(map[int][]string)
	repeatCheck := make(map[string]struct{})
	// В цикле каждое слово приводим к нижнему регистру, далее проверяем,
	// встречалось ли нам уже такое слово, если да, то сразу переходим к следующей итерации, если нет
	// то добавляем в мапу слово и считаем сумму байтов в этом слове.
	// Далее добавляем это слово в массив по ключу мапы с такой же суммой байт.
	for _, v := range arr {
		v = strings.ToLower(v)
		if _, ok := repeatCheck[v]; !ok {
			repeatCheck[v] = struct{}{}
			sum = 0
			for _, byteValue := range []byte(v) {
				sum += int(byteValue)
			}
			sumByte[sum] = append(sumByte[sum], v)
		}
	}
	// Инициализируем мапу, ключом которой является первое слово исходного массива,
	// а значением массив слов-анаграмм ключа
	anagramMap := make(map[string][]string)
	// В цикле итерируемся по массивам слов с одинаковой суммой байтов,
	// если длина масива равна 1, переходим к следующей итерации,
	// если нет то сортируем массив, ключом делаем первый элемент, а остальной массив
	// добавляем в значение по этому ключу
	for _, v := range sumByte {
		if len(v) != 1 {
			sort.Slice(v, func(i, j int) bool {
				return v[i] < v[j]
			})
			anagramMap[v[0]] = append(anagramMap[v[0]], v[1:]...)
		}
	}
	// Возвращаем полученную мапу
	return anagramMap

}
